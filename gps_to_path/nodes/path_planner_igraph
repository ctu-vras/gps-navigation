#!/usr/bin/env python

from __future__ import division
import rospy
import ros_numpy
import time
from nav_msgs.msg import Path
from sensor_msgs.msg import NavSatFix,PointCloud2
from geometry_msgs.msg import Point
from gps_to_path.msg import Waypoints
from stamped_msgs.msg import Float64
import std_msgs.msg
from geodesy import utm
import numpy as np
import osm_analysis_igraph
import shapely.geometry as geometry
import copy
import osm_types
from numpy.lib import recfunctions as rfn
from scipy.spatial import KDTree
import matplotlib.pyplot as plt
import math

plt.ion()


GRAPH_RADIUS = 20
TRAV_RADIUS = 0.5
UNTRAV_POINT_COST = 10

def dist(p1,p2):
    p1 = np.array(p1)
    p2 = np.array(p2)
    if p1.ndim > 1 or p2.ndim > 1:
        return np.sqrt(np.sum(np.square(p1-p2),axis=1))
    else:
        return np.sqrt(np.sum(np.square(p1-p2)))

class PathPlanner():
    def __init__(self, gpx_assignment, publish_pcd, goal_reached_distance):
        self.finished = False

        self.gpx_assignment = gpx_assignment
        self.publish_pcd = publish_pcd
        self.goal_reached_distance = goal_reached_distance

        # In the future replace FIX with FUSED LOCALIZATION
        self.sub_fix = rospy.Subscriber(
            "fix", NavSatFix, self.update_fix, queue_size=10)
        self.current_robot_position = None

        self.sub_azimuth = rospy.Subscriber("mag_azimuth", Float64, self.update_azimuth, queue_size=10)
        self.azimuth = None

        self.sub_trav = rospy.Subscriber(
            "trav_obstacles_pcd", PointCloud2, self.update_trav, queue_size=10)
        self.untrav_points = None

        self.untrav_cost = None

        self.pub_waypoints = rospy.Publisher(
            'waypoints', Waypoints, queue_size=10)
        self.waypoints_msg = Waypoints()

        self.osm_planner_initialized = False

        self.pub_graph_pcd = rospy.Publisher('graph_pcd', PointCloud2, queue_size=10)
        self.graph_pcd_msg = PointCloud2()

        fig,self.ax = plt.subplots()
        plt.show()
        self.art = None
        #self.art1=None
        #self.art2=None
    
    def update_trav(self,msg):
        pcd_arr = ros_numpy.numpify(msg)
        pcd_arr = rfn.structured_to_unstructured(pcd_arr)
        self.untrav_points = pcd_arr

    def update_fix(self,msg):
        utm_fix = utm.fromLatLong(msg.latitude,msg.longitude)
        self.current_robot_position = np.array([[utm_fix.easting, utm_fix.northing]])

    def update_azimuth(self, msg):
        self.azimuth = msg.data
    
    def reached_goal_point(self,robot_position,goal_point):
        if dist(np.array(robot_position), np.array(goal_point)) <= self.goal_reached_distance:
            return True
        else:
            return False
    
    def get_current_goal_point(self):
        goal_point_index = self.current_sub_graph['goal_index_graph']
        goal_point = self.current_sub_graph['graph_points'][goal_point_index]
        return goal_point

    def get_current_sub_graph(self):
        # Obtain graph which start point is the last goal point you visited.

        if self.current_sub_graph is None:
            self.current_sub_graph = self.sub_graphs.pop(0)
        
        goal_point = self.get_current_goal_point()

        if self.reached_goal_point(copy.copy(self.current_robot_position), goal_point):
            rospy.loginfo("Goal point {}/{} reached.".format(self.num_sub_graphs-len(self.sub_graphs),self.num_sub_graphs))
            if not self.sub_graphs:
                rospy.loginfo("Last goal point reached.")
                rospy.loginfo("Path planner finished.")
                self.finished = True
            else:
                self.current_sub_graph = self.sub_graphs.pop(0)
                    
    def get_nearest_graph_point_index(self, graph_dict, position):
        graph_points = graph_dict['graph_points']

        distances = dist(position,graph_points)
        nearest_index = np.argmin(distances)
        return nearest_index

    def search_graph(self, graph_dict):
        # Search current sub graph from current robot position to goal point.
        # Return a list of points (i.e. a path).
        start_index_graph = self.get_nearest_graph_point_index(graph_dict, copy.copy(self.current_robot_position))
        
        # -------- TRAV ---------
        if self.untrav_points is not None:
            t = time.time()
            graph_points = graph_dict['graph_points']
            nearest_robot_point = graph_points[start_index_graph]
            graph_tree = KDTree(graph_points)
            nearest_graph_points_ind = graph_tree.query_ball_point(nearest_robot_point, r=GRAPH_RADIUS)

            nearest_graph_points = KDTree(graph_points[nearest_graph_points_ind])
            trav_tree = KDTree(self.untrav_points)

            untrav_points_in_radius_ind = nearest_graph_points.query_ball_tree(trav_tree, r=TRAV_RADIUS)

            untrav_mask = np.zeros(len(graph_points))
            untrav_mask[nearest_graph_points_ind] = [len(a) for a in untrav_points_in_radius_ind]

            self.publish_graph_pcd(graph_points,graph_dict['graph_points_costs'],untrav_mask)

            edges = np.array(graph_dict['graph'].get_edgelist())
            #edge_points_1 = graph_points[edges[:,0]]
            #edge_points_2 = graph_points[edges[:,1]]

            untrav_cost = (untrav_mask[edges[:,0]] + untrav_mask[edges[:,1]]) * UNTRAV_POINT_COST / 2
            untrav_cost = untrav_cost.T.reshape(-1,1)

            if self.untrav_cost is not None and self.untrav_cost.shape == untrav_cost.shape:
                self.untrav_cost = 0.99 * self.untrav_cost + 0.01 * untrav_cost
            else:
                self.untrav_cost = untrav_cost

            graph_dict['graph'].es['trav_weight'] = graph_dict['graph'].es['weight'] + self.untrav_cost

            print(time.time()-t)
            #if self.art1 is not None:
            #    self.art1.remove()
            #if self.art2 is not None:
            #    self.art2.remove()
            #self.art1 = self.ax.scatter(self.untrav_points[:,0],self.untrav_points[:,1],c='blue',s=20)
            #self.art2 = self.ax.scatter(self.current_robot_position[:,0],self.current_robot_position[:,1],c='red',s=50)
            #plt.draw()
            #plt.pause(0.001)
        # -----------------------
        else:
            try:
                graph_dict['graph'].es['trav_weight']
            except:
                graph_dict['graph'].es['trav_weight'] = graph_dict['graph'].es['weight']
        
        goal_index_graph = graph_dict["goal_index_graph"]
        graph = graph_dict["graph"]

        shortest_path_vertices = graph.get_shortest_paths(start_index_graph,
                                                            goal_index_graph,
                                                            weights="trav_weight")[0]

        path = [graph_dict["graph_points"][v] for v in shortest_path_vertices]

        return path

    def utm_to_base_link(self, points):
        points = points - self.current_robot_position

        angle = -np.deg2rad(self.azimuth) - math.pi/2
        R = np.array([[np.cos(angle),-np.sin(angle)],
                        [np.sin(angle),np.cos(angle)]])
        points = np.matmul(R,points.T).T

        return points

    def publish_graph_pcd(self,points,points_cost,untrav_mask):
        dist_cost = points_cost[1].reshape(-1)
        road_cost = points_cost[2].reshape(-1)
        no_footway_cost = points_cost[3].reshape(-1)
        total_cost = points_cost[0].reshape(-1) + untrav_mask
        costs = [total_cost,dist_cost,road_cost,no_footway_cost,untrav_mask * UNTRAV_POINT_COST]
        #total_cost = total_cost.astype(np.int16)
        points = self.utm_to_base_link(points)
        self.set_graph_pcd_msg(points,costs)
        self.pub_graph_pcd.publish(self.graph_pcd_msg)

    def generate_waypoints_msg(self):
        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = "utm"

        self.waypoints_msg.header = header
        self.waypoints_msg.points = []

        for w in self.waypoints:
            p = Point()
            p.x = w[0]
            p.y = w[1]
            p.z = 0

            self.waypoints_msg.points.append(p)
    
    def get_osm_points(self):
        osm_objects = { 'roads':self.roads,
                        'untraversables':self.untraversables,
                        'footways':self.footways,
                        'all_goal_points':self.all_goal_points
                        }

        osm_points = { 'roads':np.array([]).reshape((0,2)),
                        'untraversables':np.array([]).reshape((0,2)),
                        'footways':np.array([]).reshape((0,2)),
                        'all_goal_points':np.array([]).reshape((0,2))
                        }

        for key in osm_objects:
            for ob in osm_objects[key]:
                points = ob.to_pcd_points(filled=False)
                osm_points[key] = np.concatenate([osm_points[key], points])
        
        return osm_points
    
    def squarify(self, points):
        squarish = [None] * len(points)
        for i,p in enumerate(points):
            w = osm_analysis_igraph.Way()
            x = p.x
            y = p.y
            p_squarish = geometry.Polygon([[x+1,y+1],[x-1,y+1],[x-1,y-1],[x+1,y-1]]) 
            w.line = p_squarish
            squarish[i] = w
        return np.array(squarish)

    
    def publish_osm_objects_pcd(self):
        rospy.loginfo("Generating points")
        self.roads    =  np.array(list(self.osm_planner.roads))
        self.footways =  np.array(list(self.osm_planner.footways))
        self.untraversables =  np.array(list(self.osm_planner.barriers))
        self.all_goal_points = self.osm_planner.all_goal_points
        self.all_goal_points = self.squarify(self.all_goal_points)

        self.osm_points = self.get_osm_points()
        self.pcd_msg = PointCloud2()
        self.set_pcd_msg()
        self.pub_pcd = rospy.Publisher('osm_pcd_utm', PointCloud2, queue_size=10, latch=True)
        self.pub_pcd.publish(self.osm_pcd_msg)
        rospy.loginfo("Done generating points.")
        del self.pcd_msg
        del self.pcd_data
        del self.osm_points

    def set_pcd_msg(self):
        self.pcd_data = np.zeros(0, dtype=[
                ('x', np.float32),
                ('y', np.float32),
                ('z', np.float32),
                ('type', np.uint8)])

        for key in self.osm_points:
            osm_pcd_data = np.zeros(len(self.osm_points[key]), dtype=[
                ('x', np.float32),
                ('y', np.float32),
                ('z', np.float32),
                ('type', np.uint8)])

            osm_pcd_data['x'] = self.osm_points[key][:, 0]
            osm_pcd_data['y'] = self.osm_points[key][:, 1]
            osm_pcd_data['z'] = np.zeros((self.osm_points[key][:, 1].shape))
            osm_pcd_data['type'] =  osm_types.OSM_TYPES[key] * np.ones((self.osm_points[key][:, 1].shape))

            self.pcd_data = np.concatenate([self.pcd_data, osm_pcd_data])

        self.osm_pcd_msg = ros_numpy.msgify(PointCloud2, self.pcd_data)

        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = "utm"

        self.osm_pcd_msg.header = header

    def set_graph_pcd_msg(self, points, costs):

        """ if self.art is not None:
            self.art.remove()
        self.art = self.ax.scatter(points[:,0],points[:,1])
        plt.draw()
        plt.pause(0.001) """

        pcd_data = np.zeros(len(points), dtype=[
            ('x', np.float32),
            ('y', np.float32),
            ('z', np.float32),
            ('total_cost', np.uint16),
            ('dist_cost', np.uint16),
            ('road_cost', np.uint16),
            ('no_footway_cost', np.uint16),
            ('untrav_cost', np.uint16)])

        pcd_data['x'] = points[:, 0]
        pcd_data['y'] = points[:, 1]
        pcd_data['z'] = np.zeros((points[:, 1].shape))
        pcd_data['total_cost'] =  costs[0]
        pcd_data['dist_cost'] =  costs[1]
        pcd_data['road_cost'] =  costs[2]
        pcd_data['no_footway_cost'] =  costs[3]
        pcd_data['untrav_cost'] =  costs[4]

        self.graph_pcd_msg = ros_numpy.msgify(PointCloud2, pcd_data)

        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = "base_link"

        self.graph_pcd_msg.header = header
        

    def run(self):
        rate = rospy.Rate(10)
        while not rospy.is_shutdown() and not self.finished:
            if self.osm_planner_initialized:
                self.get_current_sub_graph()
                self.waypoints = self.search_graph(self.current_sub_graph)
                self.generate_waypoints_msg()
                self.pub_waypoints.publish(self.waypoints_msg)

                rate.sleep()

            elif self.current_robot_position is not None:
                rospy.loginfo("Planner initialization started.")

                self.osm_planner = osm_analysis_igraph.PathAnalysis(self.gpx_assignment,
                                                            True,
                                                            copy.copy(self.current_robot_position))
                self.osm_planner.run_ros()

                self.sub_graphs = self.osm_planner.sub_graphs
                self.current_sub_graph = None
                self.num_sub_graphs = len(self.sub_graphs)

                self.osm_planner_initialized = True

                rospy.loginfo("Planner initialization finished.")

                if self.publish_pcd:

                    self.publish_osm_objects_pcd()
                    rospy.loginfo("OSM PCD UTM published once")
            
                    self.publish_pcd = False




def main():
    rospy.init_node('path_planner')

    gpx_assignment = rospy.get_param('~gpx_assignment', "$(find gps_to_path)/data/coords.gpx")
    goal_reached_distance = rospy.get_param('~goal_reached_distance', 3.)
    publish_pcd = rospy.get_param('~publish_pcd', True)

    node = PathPlanner(gpx_assignment,
                        publish_pcd,
                        goal_reached_distance)

    node.run()


if __name__ == '__main__':
    main()
