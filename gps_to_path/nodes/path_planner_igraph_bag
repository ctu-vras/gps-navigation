#!/usr/bin/env python

from __future__ import division

import os

import rospy
import ros_numpy
import time
from threading import Lock
from sensor_msgs.msg import NavSatFix,PointCloud2
from geometry_msgs.msg import Point
from gps_to_path.msg import Waypoints
from stamped_msgs.msg import Float64, Bool
import std_msgs.msg
from geodesy import utm
import numpy as np

try:
    import cPickle as pickle
except ImportError:
    import pickle

from tqdm import tqdm

from visualization_msgs.msg import Marker

import osm_analysis_igraph
import shapely.geometry as geometry
import copy
import osm_types
from numpy.lib import recfunctions as rfn
from scipy.spatial import KDTree
from itertools import chain
import math
import tf2_ros
from tf.transformations import quaternion_matrix,euler_from_quaternion

def dist(p1,p2):
    p1 = np.array(p1)
    p2 = np.array(p2)
    if p1.ndim > 1 or p2.ndim > 1:
        return np.sqrt(np.sum(np.square(p1-p2),axis=1))
    else:
        return np.sqrt(np.sum(np.square(p1-p2)))

class PathPlanner():
    def __init__(self,
                gpx_assignment,
                publish_pcd,
                goal_reached_distance,
                trav_max_dist,
                trav_radius,
                untrav_cost,
                absence_cost,
                max_traversable_cost,
                long_term_memory_longevity,
                short_term_memory_longevity,
                trav_inheritance_radius,
                robot_base_frame,
                max_goal_untrav_cost,
                max_path_cost,
                max_subgraph_time,
                use_osm,
                osm_use_solitary_nodes,
                repeat,
                next_waypoint_proximity_switch,
                min_time_near_goal,
                flip,
                points_absence_radius,
                max_height,
                min_height,
                max_age,
                trav_obstacle_field,
                trav_topic,
                odom_frame,
                max_relative_path_cost_change,
                heading_diff_cost):

        self.finished = False

        self.gpx_assignment = gpx_assignment
        self.publish_pcd = publish_pcd
        self.goal_reached_distance = goal_reached_distance

        self.trav_max_dist = trav_max_dist
        self.points_absence_radius = points_absence_radius

        self.trav_radius = trav_radius
        self.untrav_cost = untrav_cost
        self.absence_cost = absence_cost
        self.max_traversable_cost = max_traversable_cost

        self.long_term_memory_longevity = long_term_memory_longevity
        self.short_term_memory_longevity = short_term_memory_longevity
        self.trav_inheritance_radius = trav_inheritance_radius

        self.robot_base_frame = robot_base_frame

        self.max_goal_untrav_cost = max_goal_untrav_cost
        self.max_path_cost = max_path_cost

        self.use_osm = use_osm
        self.osm_use_solitary_nodes = osm_use_solitary_nodes

        self.repeat = repeat
        self.flip = flip

        self.next_waypoint_proximity_switch = next_waypoint_proximity_switch

        self.max_height = max_height
        self.min_height = min_height
        self.max_age = max_age
        self.odom_frame = odom_frame

        self.trav_obstacle_field = trav_obstacle_field
        self.trav_frame = None
        self.trav_topic = trav_topic

        self.max_relative_path_cost_change = max_relative_path_cost_change

        self.heading_diff_cost = heading_diff_cost

        self.min_time_near_goal = min_time_near_goal
        self.near_goal_point_time = -1
        self.near_next_waypoint_time = -1

        self.max_subgraph_time = max_subgraph_time
        self.subgraph_start_time = 0

        self.current_sub_graph_changed = True
        
        self.graph_mutex = Lock()

        self.current_path_length = 30

        self.sub_fix = rospy.Subscriber(
            "fix", NavSatFix, self.update_fix, queue_size=10)
        self.current_robot_position = None
        self.current_robot_altitude = 0

        self.sub_trav = rospy.Subscriber(
            self.trav_topic, PointCloud2, self.update_trav, queue_size=10)
        self.traversability_points = None

        self.untrav_mask = None

        self.sub_offset = rospy.Subscriber("step", std_msgs.msg.Int32, self.update_offset, queue_size=10)
        self.waypoint_offset = 0

        self.pub_path_waypoints = rospy.Publisher(
            'path_waypoints', Waypoints, queue_size=10)
        self.waypoints_msg = Waypoints()

        self.pub_original_waypoints = rospy.Publisher(
            'original_waypoints', Waypoints, queue_size=10, latch=True)

        self.pub_processed_waypoints = rospy.Publisher(
            'processed_waypoints', Waypoints, queue_size=10, latch=True)

        self.current_waypoint_marker_pub = rospy.Publisher(
            'current_waypoint', Marker, queue_size=1, latch=True)

        self.static_waypoints_published = False

        self.osm_planner_initialized = False

        self.pub_graph_pcd = rospy.Publisher('graph_pcd', PointCloud2, queue_size=10)
        self.graph_pcd_msg = PointCloud2()

        self.road_dist_pub = rospy.Publisher('road_dist', Float64, queue_size=10)

        self.is_on_road_pub = rospy.Publisher('is_on_road', Bool, queue_size=10)


        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)
        self.utm_robot_trans = None
        self.odom_robot_trans = None
        self.odom_lidar_trans = None
        self.utm_odom_trans = None
        self.odom_utm_trans = None

        self.time_diff = None

        self.mean_trav_cost_mask = None
        self.absence_mask = None

        self.original_path_cost = []
        self.shortest_path_vertices = None

        self.current_sub_graph_ind = 0


        #fig,self.ax = plt.subplots()
        #plt.show()
        #self.art = None
        #self.art1=None
        #self.art2=None

    def rotate(self,points,trans):
        R = quaternion_matrix([trans.transform.rotation.x,
                                    trans.transform.rotation.y,
                                    trans.transform.rotation.z,
                                    trans.transform.rotation.w])   
        R = R[:3,:3]
        points = np.matmul(R,points.T)
        points = points.T
        return points

    def transform_points(self,points,trans):
        points = self.rotate(points,trans)
        points[:,0] += trans.transform.translation.x
        points[:,1] += trans.transform.translation.y
        points[:,2] += trans.transform.translation.z
        return points
    
    def process_points(self,points):
        # Input: n rows, 4 cols (x,y,z,cost)
        points = points[points[:,0]!=-1.]                   # Get rid of (-1,-1,-1) points.

        points_xyz = self.transform_points(points[:,:3],self.odom_lidar_trans)

        points = np.concatenate((points_xyz, points[:,3].reshape(-1,1)),axis=1)
        
        points_height_wrt_robot = points[:,2] - self.odom_robot_trans.transform.translation.z
        
        points = points[(points_height_wrt_robot < self.max_height) &
                        (points_height_wrt_robot > self.min_height)]


        utm_points_xyz = self.transform_points(points[:,:3],self.utm_odom_trans)
        utm_points = np.concatenate((utm_points_xyz, points[:,3].reshape(-1,1)),axis=1)

        return utm_points

    def update_offset(self,msg):
        if not self.osm_planner_initialized:
            rospy.logwarn("Cannot skip waypoint. Planner not yet initialized.")
            return

        if msg.data == 0:
            return

        self.waypoint_offset += msg.data - 1  # next_waypoint() always advances by 1, so we subtract it here
        self.next_waypoint()
    
    def update_trav(self,msg):
        self.trav_frame = msg.header.frame_id
        
        # BAG ONLY ~~~~~~~~~
        if self.time_diff is None:
            self.time_diff = rospy.Time.now() - msg.header.stamp
        try:
            self.odom_robot_trans = self.tf_buffer.lookup_transform(
                self.odom_frame, self.robot_base_frame, rospy.Time())

            self.odom_lidar_trans = self.tf_buffer.lookup_transform(
                self.odom_frame, self.trav_frame, rospy.Time())

            self.utm_odom_trans = self.tf_buffer.lookup_transform(
                "utm", self.odom_frame, rospy.Time())

        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
            rospy.logwarn_once("Cannot obtain transform.")
            return

        t = rospy.Time.now()

        if self.odom_robot_trans is not None and \
        self.odom_lidar_trans is not None and \
        self.utm_odom_trans is not None and \
        abs((msg.header.stamp + self.time_diff - t).to_sec()) < self.max_age:    # BAG: abs((msg.header.stamp + self.time_diff - t).to_sec()) < self.max_age:
            pcd_struct = ros_numpy.numpify(msg)
            pcd_arr = rfn.structured_to_unstructured(pcd_struct[['x','y','z',self.trav_obstacle_field]])
            #pcd_arr = pcd_arr[np.where(pcd_arr[:,-1] > 0.5)]        # works for both trav types
            #pcd_arr = pcd_arr[:,:3]

            self.traversability_points = self.process_points(pcd_arr)
        
    def update_fix(self,msg):
        utm_fix = utm.fromLatLong(msg.latitude,msg.longitude)
        self.current_robot_position = np.array([[utm_fix.easting, utm_fix.northing]])
        #self.current_robot_altitude = msg.altitude

    def reached_goal_point(self,robot_position,goal_point):
        robot_position_temp = copy.copy(robot_position)

        #rospy.logwarn(dist(np.array(robot_position_temp), np.array(goal_point)), self.goal_reached_distance)

        if dist(np.array(robot_position_temp), np.array(goal_point)) <= self.goal_reached_distance:
            return True
        else:
            return False
    
    def get_current_goal_point(self):
        goal_point_index = self.current_sub_graph['goal_index_graph']
        goal_point = self.current_sub_graph['graph_points'][goal_point_index]
        return goal_point

    def get_current_path_length(self):
        goal_i = self.current_sub_graph['goal_index_graph']
        start_i = self.current_sub_graph['start_index_graph']

        goal_point = self.current_sub_graph['graph_points'][goal_i]
        start_point = self.current_sub_graph['graph_points'][start_i]

        length = dist(goal_point,start_point)
        return length

    def get_current_sub_graph(self):
        # Obtain graph which start point is the last goal point you visited.
        call_next_waypoint = False
        sub_graph_ind = self.current_sub_graph_ind + self.waypoint_offset

        with self.graph_mutex:
            if self.current_sub_graph is None:
                self.current_sub_graph = self.sub_graphs[sub_graph_ind]
                self.subgraph_start_time = rospy.Time.now()
                self.current_sub_graph_changed = True
    
            goal_point = self.get_current_goal_point()

            self.current_path_length = self.get_current_path_length()
            
            """ if sub_graph_ind < len(self.sub_graphs) - 1:
                next_goal_point = self.sub_graphs[sub_graph_ind + 1]['graph_points'][self.sub_graphs[sub_graph_ind + 1]['goal_index_graph']]
            else:
                next_goal_point = None """
    
            if self.reached_goal_point(self.current_robot_position, goal_point):
                if self.near_goal_point_time <= 0:
                    self.near_goal_point_time = rospy.Time.now().to_sec()
    
                if rospy.Time.now().to_sec() - self.near_goal_point_time >= self.min_time_near_goal:
                    rospy.loginfo("Goal point {}/{} reached.".format(sub_graph_ind,self.num_sub_graphs))
                    call_next_waypoint = True
                    self.near_goal_point_time = -1.  
            # Switch to next goal_point if nearby it.
            """ elif next_goal_point is not None and self.next_waypoint_proximity_switch and self.reached_goal_point(self.current_robot_position, next_goal_point):
                if self.near_next_waypoint_time <= 0:
                    self.near_next_waypoint_time = rospy.Time.now().to_sec()
    
                if rospy.Time.now().to_sec() - self.near_next_waypoint_time >= self.min_time_near_goal:
                    call_next_waypoint = True
                    self.near_next_waypoint_time = -1.     """  
    
            if (rospy.Time.now() - self.subgraph_start_time).to_sec() > self.max_subgraph_time * self.current_path_length:
                rospy.loginfo("Subgraph timed out after {}. Goal point {}/{} not reached. Moving onto the next one".format(
                    round((rospy.Time.now() - self.subgraph_start_time).to_sec(),2),
                    sub_graph_ind,
                    self.num_sub_graphs))
    
                call_next_waypoint = True
                self.near_goal_point_time = -1.

        if call_next_waypoint:
            self.next_waypoint()
                    
    def get_nearest_graph_point_index(self, graph_points, position):
        distances = dist(position,graph_points)
        nearest_index = np.argmin(distances)
        return nearest_index

    def next_waypoint(self):
        # No more waypoints. Finish.
        with self.graph_mutex:
            sub_graph_ind = self.current_sub_graph_ind + self.waypoint_offset
            if sub_graph_ind >= len(self.sub_graphs) - 1:
                rospy.loginfo("Last goal point reached.")
                rospy.loginfo("Path planner finished.")

                if self.repeat:
                    rospy.loginfo("Repeating path from first waypoint.")

                    self.sub_graphs = copy.copy(self.all_sub_graphs)

                    # Replace the previous start position of robot to first waypoint...
                    self.sub_graphs.pop(0)

                    first_waypoint = geometry.Point(np.ravel(self.sub_graphs[0]['graph_points'][self.sub_graphs[0]['goal_index_graph']]))
                    current_position_point = geometry.Point(np.ravel(self.current_robot_position))
                    current_pos_to_start_point_graph = self.osm_planner.generate_graph(current_position_point, first_waypoint)

                    # ... with current position of robot to first waypoint.
                    self.sub_graphs.insert(0, current_pos_to_start_point_graph)
                    sub_graph_ind = 0

                else:
                    self.finished = True

            # Pop next subgraph.
            else:
                self.current_sub_graph_ind += 1
                self.current_sub_graph = self.sub_graphs[sub_graph_ind+1]
                self.current_sub_graph_changed = True

            self.near_goal_point_time = -1
            self.near_next_waypoint_time = -1
            self.subgraph_start_time = rospy.Time.now()

            self.original_path_cost = []
            self.shortest_path_vertices = None

            marker = Marker()
            marker.header.stamp = rospy.Time.now()
            marker.header.frame_id = "utm"
            marker.id = 0
            marker.ns = "current_waypoint"
            marker.action = Marker.ADD
            marker.pose.position.z = self.current_robot_altitude
            marker.pose.orientation.w = 1
            marker.scale.x = marker.scale.y = marker.scale.z = 2
            marker.color.a = 0.5
            if self.finished:
                marker.type = Marker.SPHERE
                marker.pose.position.x, marker.pose.position.y = np.ravel(self.current_robot_position)
                marker.color.g = 1
            else:
                marker.type = Marker.CUBE
                sub_graph = self.sub_graphs[sub_graph_ind + 1]
                current_waypoint = np.ravel(sub_graph['graph_points'][sub_graph['goal_index_graph']])
                marker.pose.position.x, marker.pose.position.y = current_waypoint
                marker.color.r = 1
            self.current_waypoint_marker_pub.publish(marker)

    def search_graph(self):
        """ 
        Search current sub graph from current robot position to goal point.
        Returns:
            If found path a list of points (i.e. a path).
            If no path found, or goal point untraversable returns None.
        """
        t = time.time()
        t1 = time.time()
        
        with self.graph_mutex:
            graph_dict = self.current_sub_graph
    
            goal_index_graph = graph_dict["goal_index_graph"]
    
            graph = graph_dict["graph"]
    
            graph_points = graph_dict['graph_points']
    
            start_index = self.get_nearest_graph_point_index(graph_points, copy.copy(self.current_robot_position))
    
            
            
            # -------- TRAV ---------
            traversability_points = copy.copy(self.traversability_points)
            if traversability_points is not None and traversability_points.size > 0:
            #try:
                traversability_points[[np.where(np.isnan(traversability_points[:,3]))],3] = 0
    
                graph_points = graph_dict['graph_points']
    
                nearest_robot_point = graph_points[start_index]
                graph_tree = KDTree(graph_points)
    
                nearest_graph_points_inds = graph_tree.query_ball_point(nearest_robot_point, r=self.trav_max_dist)
                graph_points_absence_radius_inds = graph_tree.query_ball_point(nearest_robot_point, r=self.points_absence_radius)
    
                nearest_graph_points = graph_points[nearest_graph_points_inds]
                nearest_graph_points_tree = KDTree(nearest_graph_points)


                ######### ROBOT HEADING COST MASK ##########
                # TODO: TAKE INTO CONSIDERATION ROBOT MOVING BACKWARDS
                self.utm_robot_trans = self.tf_buffer.lookup_transform("utm", self.robot_base_frame, rospy.Time())
                quat = self.utm_robot_trans.transform.rotation

                robot_heading = euler_from_quaternion([quat.x,quat.y,quat.z,quat.w])[2]

                if robot_heading < 0:
                    robot_heading += 2*math.pi

                goal_point = graph_points[goal_index_graph] - nearest_robot_point
                goal_angle = np.angle([goal_point[0] + goal_point[1]*1j])
                if goal_angle < 0:
                    goal_angle += 2*math.pi
                
                heading_diff_cost_inds = graph_tree.query_ball_point(nearest_robot_point, r=3.)
                rotation_points = graph_points[heading_diff_cost_inds]-nearest_robot_point
                rotation_points_angles = np.angle(rotation_points[:,0] + rotation_points[:,1]*1j)

                rotation_points_angles[rotation_points_angles<0] += 2*math.pi

                rotation_points_angles = rotation_points_angles.reshape(-1,1)

                rotation_points_angles_diff = np.amin(np.fabs(np.concatenate((rotation_points_angles-robot_heading,
                                                                    rotation_points_angles+2*math.pi-robot_heading,
                                                                    rotation_points_angles-2*math.pi-robot_heading),axis=1)),axis=1)

                if np.fabs(robot_heading - goal_angle) <= 1.1*math.pi/4:
                    heading_diff_cost_angles = rotation_points_angles_diff
                    heading_diff_cost_angles[heading_diff_cost_angles > math.pi] #-= math.pi
                else:
                    heading_diff_cost_angles = np.zeros(rotation_points_angles_diff.shape)

                heading_diff_cost_mask = np.zeros(len(graph_points))
                heading_diff_cost_mask[heading_diff_cost_inds] = heading_diff_cost_angles 

                ###################

                #absence_radius_points = KDTree(graph_points[graph_points_absence_radius_inds])
                #absence_radius_points = graph_points[graph_points_absence_radius_inds]
                absence_in_nearest_correspondence = np.argwhere(np.isin(nearest_graph_points_inds,graph_points_absence_radius_inds,assume_unique=True)).ravel()
                trav_tree = KDTree(traversability_points[:,:2])    # take x,y only
    
                traversability_points_in_radius_ind = nearest_graph_points_tree.query_ball_tree(trav_tree, r=self.trav_radius)
    
                #traversability_points_in_absence_radius_ind = absence_radius_points.query_ball_tree(trav_tree, r=self.trav_radius)
            
                # WORKS ONLY WITH COST BETWEEN 0 AND 1 (or binary 0/1)
                near_mean_trav_cost_mask = np.array([np.mean(traversability_points[inds,3]) if len(inds) > 0 else -1 for inds in traversability_points_in_radius_ind])
    
                traversability_score_in_absence_radius_ind = near_mean_trav_cost_mask[absence_in_nearest_correspondence]
                #near_absence_mask = np.array([True if inds==-1 else False for inds in traversability_score_in_absence_radius_ind])
                near_absence_mask = traversability_score_in_absence_radius_ind == -1
    
                no_lidar_points = np.where([near_mean_trav_cost_mask == -1])
                nearest_graph_points_inds = np.delete(nearest_graph_points_inds, no_lidar_points)
                near_mean_trav_cost_mask = np.delete(near_mean_trav_cost_mask, no_lidar_points)
                #near_mean_trav_cost_mask[near_mean_trav_cost_mask == -1] = 0
                #near_absence_mask = np.array([False if len(inds) > 0 else True for inds in traversability_points_in_absence_radius_ind])
                
                #num_trav_points_mask = np.array([len(a) for a in traversability_points_in_radius_ind])
    
                #untrav_mask = np.zeros(len(graph_points))
                #untrav_mask[nearest_graph_points_ind] = [len(a) for a in traversability_points_in_radius_ind]
    
                #near_points_untrav_mask = np.zeros(len(nearest_graph_points_ind))
                #near_points_untrav_mask = np.array([len(a) for a in traversability_points_in_radius_ind])
    
                # Near graph vertices cost is equal to number of nearby untrav points and the rest of the mask is zeros.
                #untrav_mask[nearest_graph_points_ind] = near_points_untrav_mask
                
                #except:
                #    trav_tree = KDTree(graph_points)
                #    traversability_points_in_radius_ind = nearest_graph_points.query_ball_tree(trav_tree, r=self.trav_radius)
                #    near_points_untrav_mask = np.array([0 for a in traversability_points_in_radius_ind])
    
                # Initialization of absence mask.
                #if self.absence_mask is None:
                #    absence_mask = np.zeros(len(graph_points)) * self.absence_default_cost
                #    self.absence_mask = absence_mask
                #    self.current_sub_graph_changed = False
                # Initialization of trav mask.
                if self.mean_trav_cost_mask is None:             
                    mean_trav_cost_mask = np.zeros(len(graph_points))
                    self.mean_trav_cost_mask = mean_trav_cost_mask
                    self.current_sub_graph_changed = False
    
                if self.absence_mask is None:
                    self.absence_mask = np.full((len(graph_points)), True)
                    self.absence_mask[graph_points_absence_radius_inds] = False # When init, clear the area around robot.
    
                # Inheritance of trav mask between near vertices of previous and new subgraph when subgraph changes.
                if self.mean_trav_cost_mask is not None and self.current_sub_graph_changed == True:
                    previous_points_tree = KDTree(self.previous_points)
                    dists,inds = previous_points_tree.query(graph_points)
    
                    new_mask = np.zeros((len(graph_points)))
                    new_absence_mask = np.full((len(graph_points)), True)
    
                    new_mask_inds = np.arange(len(new_mask))
    
                    inds = inds[dists <= self.trav_inheritance_radius]
                    new_mask_inds = new_mask_inds[dists <= self.trav_inheritance_radius]
    
                    new_mask[new_mask_inds] = self.mean_trav_cost_mask[inds]
                    new_absence_mask[new_mask_inds] = self.absence_mask[inds]
    
                    self.mean_trav_cost_mask = new_mask
                    self.absence_mask = new_absence_mask
    
                    self.absence_mask[graph_points_absence_radius_inds] = False # When init, clear the area around robot.
    
                    self.current_sub_graph_changed = False
    
                # Trav update.
                #if self.untrav_mask is not None and self.current_sub_graph_changed == False:
                    
                    # The near points are fully updated based on last trav pcd.
                    #self.untrav_mask[nearest_graph_points_ind] = near_points_untrav_mask
    
                    # The whole mask ages.
                    #self.untrav_mask = self.memory_longevity * self.untrav_mask
                    #current_mask_is_larger = untrav_mask > self.untrav_mask
                    #self.untrav_mask[current_mask_is_larger] = untrav_mask[current_mask_is_larger]
                    #self.untrav_mask[~current_mask_is_larger] = self.memory_longevity * self.untrav_mask[~current_mask_is_larger] + (1-self.memory_longevity) * untrav_mask[~current_mask_is_larger]
    
                # Trav update.
                # The near points are fully updated based on last trav pcd.
                #print(self.short_term_memory_longevity)
                #print(self.untrav_mask[nearest_graph_points_ind])
                #print((1-self.short_term_memory_longevity))
                #print(near_points_untrav_mask)
                
                self.absence_mask[graph_points_absence_radius_inds] = np.logical_and(self.absence_mask[graph_points_absence_radius_inds], near_absence_mask)
                
                absence_cost_mask = np.zeros(len(graph_points))
                absence_cost_mask[graph_points_absence_radius_inds] = self.absence_mask[graph_points_absence_radius_inds]*self.absence_cost
                
                #near_mean_trav_cost_mask[near_mean_trav_cost_mask == -1] = 0
                self.mean_trav_cost_mask[nearest_graph_points_inds] = self.short_term_memory_longevity * self.mean_trav_cost_mask[nearest_graph_points_inds] + (1-self.short_term_memory_longevity) * near_mean_trav_cost_mask
    
                # The whole mask ages.
                self.mean_trav_cost_mask = self.long_term_memory_longevity * self.mean_trav_cost_mask
                
                self.previous_points = graph_points # previous points used when the subgraph changes (trav inheritance)
    
                #edges2 = np.array(graph_dict['graph'].get_edgelist())   # SLOWNESS CULPRIT 1 (bellow line is faster)
                edges = np.fromiter(chain(*graph_dict['graph'].get_edgelist()), np.dtype('i'), count=-1).reshape(-1, 2)
    
                #edge_points_1 = graph_points[edges[:,0]]
                #edge_points_2 = graph_points[edges[:,1]]
    
                trav_and_absence_mask = self.mean_trav_cost_mask * self.untrav_cost + absence_cost_mask
                trav_and_absence_mask[start_index] = 0 # ZERO THE TRAV COST OF CURRENT ROBOT VORTEX

                trav_and_absence_mask[trav_and_absence_mask >= self.max_traversable_cost] = float('inf')  # oprahovani

                trav_and_absence_and_heading_mask = trav_and_absence_mask + heading_diff_cost_mask * self.heading_diff_cost
    
                untrav_cost = (trav_and_absence_and_heading_mask[edges[:,0]] + trav_and_absence_and_heading_mask[edges[:,1]]) / 2
                untrav_cost = untrav_cost.T.reshape(-1,1)
                
                total_cost = graph_dict['graph'].es['weight'] + untrav_cost
                graph_dict['graph'].es['total_weight'] = total_cost  # SLOWNESS CULPRIT
                # Publish the graph as pcd for vizualization.
                self.publish_graph_pcd(graph_points,graph_dict['graph_points_costs'],self.mean_trav_cost_mask,absence_cost_mask,trav_and_absence_mask,heading_diff_cost_mask)
    
                #if self.art1 is not None:
                #    self.art1.remove()
                #if self.art2 is not None:
                #    self.art2.remove()
                #self.art1 = self.ax.scatter(self.untrav_points[:,0],self.untrav_points[:,1],c='blue',s=20)
                #self.art2 = self.ax.scatter(self.current_robot_position[:,0],self.current_robot_position[:,1],c='red',s=50)
                #plt.draw()
                #plt.pause(0.001)
                # -----------------------
                #print(graph_dict['start_index_graph'],goal_index_graph)
                # If waypoint (current goal point) is untraversable - choose the point on the line along the gas pipe.
                if self.mean_trav_cost_mask[goal_index_graph] > self.max_goal_untrav_cost:
                    rospy.logwarn("Waypoint {}/{} is untraversable. Moving goal one point closer.".format(self.num_sub_graphs-len(self.sub_graphs),self.num_sub_graphs))
                    graph_dict['goal_index_graph'] -= 1
        
                    #self.next_waypoint()
                    return None
    
                #except Exception as e:
                #    print(e)
            else:
                cost_shape = graph_dict['graph_points_costs'][0].reshape(-1).shape
                cost_placeholder = np.zeros(cost_shape)
                self.publish_graph_pcd(graph_points,graph_dict['graph_points_costs'],cost_placeholder,cost_placeholder,cost_placeholder,cost_placeholder)
    
            # Else triggers if no or empty trav msg has arrived yet. In that case we simply use the base weights.
            # Try except here for initialization if the variable has not been initialized yet.
            try:
                graph_dict['graph'].es['total_weight']
            except:
                graph_dict['graph'].es['total_weight'] = graph_dict['graph'].es['weight']
    
            
    
            # Check how the cost of the last published path changed in comparison to its original cost.
            # If it is relatively more expensive than some threshold, try replanning.
            replan = True
            if self.shortest_path_vertices is not None and len(self.shortest_path_vertices) > 0:
                shortest_path_graph_points = [graph_points[v] for v in self.shortest_path_vertices]
                robot_on_path_index = self.get_nearest_graph_point_index(shortest_path_graph_points, copy.copy(self.current_robot_position))
    
                original_path_cost_sum = np.sum(self.original_path_cost[robot_on_path_index:])
                current_path_cost = 0
                for i in range(len(self.shortest_path_vertices[robot_on_path_index:])-1):
                    v1 = self.shortest_path_vertices[robot_on_path_index+i]
                    v2 = self.shortest_path_vertices[robot_on_path_index+i+1]
                    edge = graph.get_eid(v1,v2)
                    current_path_cost += graph.es[edge]["total_weight"]
    
                if (current_path_cost/min([original_path_cost_sum,0.0001]) <= self.max_relative_path_cost_change) or dist(copy.copy(self.current_robot_position),shortest_path_graph_points[robot_on_path_index]) > 5:
                    replan = False
                    
                """ print(">././>?>?>/./>?>/./>?././")
                print(dist(copy.copy(self.current_robot_position),shortest_path_graph_points[robot_on_path_index]))
                print(robot_on_path_index)
                print(self.shortest_path_vertices)
                print(original_path_cost_sum)
                print(current_path_cost)
                print(">././>?>?>/./>?>/./>?././") """
            
    
    
            if replan:
                # Replan.
                self.shortest_path_vertices = graph.get_shortest_paths(start_index,
                                                                    goal_index_graph,
                                                                    weights="total_weight",
                                                                    output="vpath")[0]
    
                cost = 0
                self.original_path_cost = np.zeros(len(self.shortest_path_vertices)-1)
                for i in range(len(self.shortest_path_vertices)-1):
                    v1 = self.shortest_path_vertices[i]
                    v2 = self.shortest_path_vertices[i+1]
                    edge = graph.get_eid(v1,v2)
                    #print(graph.es[edge]["total_weight"])
                    #cost += graph.es[edge]["total_weight"]
                    self.original_path_cost[i] = graph.es[edge]["total_weight"]
                
                if np.sum(self.original_path_cost) >= float('inf'):
                    # Publish empty path (stop the robot).
                    rospy.logwarn("Infinite path cost. Publishing empty path.")
                    self.shortest_path_vertices = []
                    self.original_path_cost = 0.0001
    
                #print(cost)
                #print("----------------------")
                
                # Maximum cost is very hard to balance. For now not used.
                #if cost > self.max_path_cost:
                #    rospy.logwarn("Path to waypoint {}/{} is too expensive ({}). Moving onto the next waypoint.".format(self.num_sub_graphs-len(self.sub_graphs),self.num_sub_graphs, cost))
                #    self.next_waypoint()
                #    return None
    
            path = [graph_points[v] for v in self.shortest_path_vertices]
            print("TOTAL TIME: {}".format(time.time()-t1))
            return path
    
    def inverse_transform_matrix(self,rotation_m,translation_m):
        trans_m = np.concatenate((rotation_m,translation_m),axis=1)
        trans_m = np.concatenate((trans_m,np.array([0,0,0,1]).reshape(1,4)),axis=0)
        try:
            inv_trans_m = np.linalg.inv(trans_m)
            inv_trans_m = inv_trans_m[:3,:3]
            return inv_trans_m

        except Exception as e:
            print(e)
            return np.eye(3)

    def publish_graph_pcd(self,points,points_cost,mean_trav_cost_mask,absence_cost_mask,trav_and_absence_mask,heading_diff_cost_mask):

        heading_diff_cost_mask_temp = heading_diff_cost_mask * self.heading_diff_cost
        mean_trav_cost_mask_temp = mean_trav_cost_mask * self.untrav_cost

        if self.use_osm and len(points_cost) >= 5: # it should have 5 items
            dist_cost = points_cost[1].reshape(-1)
            road_cost = points_cost[2].reshape(-1)
            no_footway_cost = points_cost[3].reshape(-1)
            barrier_cost = points_cost[4].reshape(-1)
            osm_costs_added = points_cost[0].reshape(-1)
            total_cost = osm_costs_added + mean_trav_cost_mask_temp + absence_cost_mask + heading_diff_cost_mask_temp 
            costs = [total_cost,dist_cost,road_cost,no_footway_cost,barrier_cost,mean_trav_cost_mask_temp, absence_cost_mask, trav_and_absence_mask, heading_diff_cost_mask_temp]
        else:
            dist_cost = points_cost[0].reshape(-1)
            total_cost = dist_cost + mean_trav_cost_mask_temp + absence_cost_mask + heading_diff_cost_mask_temp
            costs = [total_cost,dist_cost,np.zeros(dist_cost.shape),np.zeros(dist_cost.shape),np.zeros(dist_cost.shape),mean_trav_cost_mask_temp, absence_cost_mask, trav_and_absence_mask, heading_diff_cost_mask_temp]
        #total_cost = total_cost.astype(np.int16)
        #points = self.utm_to_base_frame(points)

        #points = self.transform_points(np.concatenate((points,np.zeros((points.shape[0],1))), axis=1), self.utm_odom_trans)
        #print(points)

        if self.odom_robot_trans is not None and self.utm_odom_trans is not None:

            robot_z = self.odom_robot_trans.transform.translation.z + self.utm_odom_trans.transform.translation.z
            points = np.concatenate((points,robot_z * np.ones((points.shape[0],1))), axis=1)
            try:
                self.odom_utm_trans = self.tf_buffer.lookup_transform(
                        self.odom_frame, "utm", rospy.Time())
                points = self.transform_points(points, self.odom_utm_trans)
                self.set_graph_pcd_msg(points,costs,self.odom_frame)
                self.pub_graph_pcd.publish(self.graph_pcd_msg)
            except:
                self.set_graph_pcd_msg(points,costs,"utm")
                self.pub_graph_pcd.publish(self.graph_pcd_msg)


    def generate_waypoints_msg(self, points):
        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = "utm"

        msg = Waypoints()

        msg.header = header
        msg.points = []

        for w in points:
            p = Point()
            p.x = w[0]
            p.y = w[1]
            p.z = 0

            msg.points.append(p)

        return msg
    
    """ def get_osm_points(self):
        osm_objects = { 'roads':self.roads,
                        'untraversables':self.untraversables,
                        'footways':self.footways,
                        'all_goal_points':self.all_goal_points
                        }

        osm_points = { 'roads':np.array([]).reshape((0,2)),
                        'untraversables':np.array([]).reshape((0,2)),
                        'footways':np.array([]).reshape((0,2)),
                        'all_goal_points':np.array([]).reshape((0,2))
                        }

        for key in osm_objects:
            for ob in osm_objects[key]:
                points = ob.to_pcd_points(filled=False)
                osm_points[key] = np.concatenate([osm_points[key], points])
        
        return osm_points
    
    def squarify(self, points):
        squarish = [None] * len(points)
        for i,p in enumerate(points):
            w = osm_analysis_igraph.Way()
            x = p.x
            y = p.y
            p_squarish = geometry.Polygon([[x+1,y+1],[x-1,y+1],[x-1,y-1],[x+1,y-1]]) 
            w.line = p_squarish
            squarish[i] = w
        return np.array(squarish)

    
    def publish_osm_objects_pcd(self):
        rospy.loginfo("Generating points")
        self.roads    =  np.array(list(self.osm_planner.roads))
        self.footways =  np.array(list(self.osm_planner.footways))
        self.untraversables =  np.array(list(self.osm_planner.barriers))
        self.all_goal_points = copy.copy(self.osm_planner.all_goal_points)
        self.all_goal_points = self.squarify(self.all_goal_points)

        self.osm_points = self.get_osm_points()
        self.pcd_msg = PointCloud2()
        self.set_pcd_msg()
        self.pub_pcd = rospy.Publisher('osm_pcd_utm', PointCloud2, queue_size=10, latch=True)
        self.pub_pcd.publish(self.osm_pcd_msg)
        rospy.loginfo("Done generating points.")
        del self.pcd_msg
        del self.pcd_data
        #del self.osm_points

    def set_pcd_msg(self):
        self.pcd_data = np.zeros(0, dtype=[
                ('x', np.float32),
                ('y', np.float32),
                ('z', np.float32),
                ('type', np.uint8)])

        for key in self.osm_points:
            osm_pcd_data = np.zeros(len(self.osm_points[key]), dtype=[
                ('x', np.float32),
                ('y', np.float32),
                ('z', np.float32),
                ('type', np.uint8)])

            osm_pcd_data['x'] = self.osm_points[key][:, 0]
            osm_pcd_data['y'] = self.osm_points[key][:, 1]
            osm_pcd_data['z'] = np.zeros((self.osm_points[key][:, 1].shape))
            osm_pcd_data['type'] =  osm_types.OSM_TYPES[key] * np.ones((self.osm_points[key][:, 1].shape))

            self.pcd_data = np.concatenate([self.pcd_data, osm_pcd_data])

        self.osm_pcd_msg = ros_numpy.msgify(PointCloud2, self.pcd_data)

        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = "utm"

        self.osm_pcd_msg.header = header """

    def set_graph_pcd_msg(self, points, costs, frame):

        """ if self.art is not None:
            self.art.remove()
        self.art = self.ax.scatter(points[:,0],points[:,1])
        plt.draw()
        plt.pause(0.001) """

        pcd_data = np.zeros(len(points), dtype=[
            ('x', np.float32),
            ('y', np.float32),
            ('z', np.float32),
            ('total_cost', np.float32),
            ('dist_cost', np.float32),
            ('road_cost', np.float32),
            ('no_footway_cost', np.float32),
            ('barrier_cost', np.float32),
            ('untrav_cost', np.float32),
            ('absence_cost', np.float32),
            ('forbidden_cost', np.float32),
            ('heading_diff_cost', np.float32)
            ])

        pcd_data['x'] = points[:, 0]
        pcd_data['y'] = points[:, 1]
        pcd_data['z'] = points[:, 2] #np.zeros((points[:, 1].shape))
        pcd_data['total_cost'] =  costs[0]
        pcd_data['dist_cost'] =  costs[1]
        pcd_data['road_cost'] =  costs[2]
        pcd_data['no_footway_cost'] =  costs[3]
        pcd_data['barrier_cost'] =  costs[4]
        pcd_data['untrav_cost'] =  costs[5]
        pcd_data['absence_cost'] =  costs[6]
        pcd_data['forbidden_cost'] =  costs[7]
        pcd_data['heading_diff_cost'] =  costs[8]

        self.graph_pcd_msg = ros_numpy.msgify(PointCloud2, pcd_data)

        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        #header.frame_id = self.robot_base_frame
        header.frame_id = frame

        self.graph_pcd_msg.header = header
    
    """ def publish_robot_road_dist(self):
        road_points = self.osm_points['roads']
        roads_tree = KDTree(road_points)
        dist,_ = roads_tree.query(self.current_robot_position)

        road_dist_msg = Float64()

        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = self.robot_base_frame

        road_dist_msg.header = header
        road_dist_msg.data = dist

        self.road_dist_pub.publish(road_dist_msg) """

    def publish_robot_is_on_road(self):
        robot_position = geometry.Point(np.ravel(self.current_robot_position))
        is_on_road = False

        for road in self.roads:
            if road.line.contains(robot_position):
                is_on_road = True
                break

        is_on_road_msg = Bool()

        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = self.robot_base_frame

        is_on_road_msg.header = header
        is_on_road_msg.data = is_on_road

        self.is_on_road_pub.publish(is_on_road_msg)      

    def publish_static_waypoints(self):
        processed_waypoints_msg = Waypoints()
        original_waypoints_msg = Waypoints()

        processed_waypoints_msg = self.generate_waypoints_msg(np.array(list(geometry.LineString(self.osm_planner.all_goal_points).xy)).T)
        original_waypoints_msg = self.generate_waypoints_msg(self.osm_planner.waypoints[1:,:]) # First point is starting robot position - throw away.

        self.pub_processed_waypoints.publish(processed_waypoints_msg)
        self.pub_original_waypoints.publish(original_waypoints_msg)
        
    def run(self):
        rate = rospy.Rate(100)
        while not rospy.is_shutdown() and not self.finished:
            try:
                self.odom_robot_trans = self.tf_buffer.lookup_transform(
                    self.odom_frame, self.robot_base_frame, rospy.Time())

                self.utm_odom_trans = self.tf_buffer.lookup_transform(
                    "utm", self.odom_frame, rospy.Time())

            except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
                rospy.logwarn_once("Cannot obtain transform.")

            if self.osm_planner_initialized:
                
                self.get_current_sub_graph()
                self.waypoints = self.search_graph()
                

                """ if self.osm_points['roads'].size != 0:
                    self.publish_robot_road_dist()
                    self.publish_robot_is_on_road() """
                
                if self.waypoints is not None:
                    self.waypoints_msg = self.generate_waypoints_msg(self.waypoints)
                    self.pub_path_waypoints.publish(self.waypoints_msg)
                
                # Publish original and processed (OSM, max_dist...) waypoints. 
                if not self.static_waypoints_published:
                    self.publish_static_waypoints()
                    self.static_waypoints_published = True

                rate.sleep()
                
            elif self.current_robot_position is not None:
                """ rospy.loginfo("Planner initialization started.")

                self.osm_planner = osm_analysis_igraph.PathAnalysis(self.gpx_assignment,
                                                            True,
                                                            copy.copy(self.current_robot_position),
                                                            self.use_osm,
                                                            self.osm_use_solitary_nodes,
                                                            self.flip)
                self.osm_planner.run_ros() """

                osm_fn = self.gpx_assignment[:-3]+"osm_planner"

                try:
                    rospy.loginfo("Loading OSM data from pickle {}.".format(osm_fn))
                    with open(osm_fn, 'rb') as handle:
                        total = os.path.getsize(osm_fn)
                        with TQDMBytesReader(handle, total=total) as handle_with_progress:
                            self.osm_planner = pickle.load(handle_with_progress)
                    rospy.loginfo("OSM data loaded.")

                except Exception as e:
                    rospy.logwarn("OSM pickle {} not loaded (error is {}).".format(osm_fn, str(e)))
                    rospy.logwarn("Running OSM analysis instead.")
                    self.osm_planner = osm_analysis_igraph.PathAnalysis(self.gpx_assignment,
                                                            True,
                                                            copy.copy(self.current_robot_position),
                                                            self.use_osm,
                                                            self.osm_use_solitary_nodes,
                                                            self.flip)
                    self.osm_planner.run_ros()
                    rospy.logwarn("Saving the analysis to pickle.")
                    self.osm_planner.save_to_pickle()
                    rospy.logwarn("Saving finished.")

                self.sub_graphs = self.osm_planner.sub_graphs

                if hasattr(self.osm_planner, 'robot_position_first_point') and self.osm_planner.robot_position_first_point:
                    self.sub_graphs.pop(0)  # Get rid of the fake start position from pickler.

                first_waypoint = geometry.Point(np.ravel(self.sub_graphs[0]['graph_points'][self.sub_graphs[0]['start_index_graph']]))
                current_position_point = geometry.Point(np.ravel(self.current_robot_position))

                current_pos_to_start_point_graph = self.osm_planner.generate_graph(current_position_point, first_waypoint)

                self.sub_graphs.insert(0, current_pos_to_start_point_graph)
                    
                if self.repeat:
                    self.all_sub_graphs = copy.copy(self.sub_graphs)

                self.current_sub_graph = None
                self.num_sub_graphs = len(self.sub_graphs)

                self.osm_planner_initialized = True

                rospy.loginfo("Planner initialization finished.")

                """ if self.publish_pcd:

                    self.publish_osm_objects_pcd()
                    rospy.loginfo("OSM PCD UTM published once")
            
                    self.publish_pcd = False """

        # When finished send one empty waypoints msg to overwrite the previous msg.
        self.publish_empty_path()

    def publish_empty_path(self):
        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = "utm"

        self.waypoints_msg.header = header
        self.waypoints_msg.points = []
        self.pub_path_waypoints.publish(self.waypoints_msg)

def main():
    rospy.init_node('path_planner')

    gpx_assignment = rospy.get_param('~gpx_assignment', "$(find gps_to_path)/data/coords.gpx")
    goal_reached_distance = rospy.get_param('~goal_reached_distance', 1.)
    publish_pcd = rospy.get_param('~publish_pcd', True)
    trav_max_dist = rospy.get_param('~trav_max_dist', 10.)
    points_absence_radius = rospy.get_param('~points_absence_radius', 2.)
    trav_radius = rospy.get_param('~trav_radius', 0.5)
    untrav_cost = rospy.get_param('~untrav_cost', 10.)
    absence_cost = rospy.get_param('~absence_cost', 1000.)
    max_traversable_cost = rospy.get_param('~max_traversable_cost', 50.)
    long_term_memory_longevity = rospy.get_param('~long_term_memory_longevity', 0.997)
    short_term_memory_longevity = rospy.get_param('~short_term_memory_longevity', 0.8)
    trav_inheritance_radius = rospy.get_param('~trav_inheritance_radius', 0.71)    # graph_lattice_size * sqrt(2)/2 is recommended
    robot_base_frame = rospy.get_param('~robot_base_frame', 'base_link')
    max_goal_untrav_cost = rospy.get_param('~max_goal_untrav_cost', 200.)
    max_path_cost = rospy.get_param('~max_path_cost', 100.)
    max_subgraph_time = rospy.get_param('~max_subgraph_time', 30.)
    use_osm = rospy.get_param('~use_osm', True)
    osm_use_solitary_nodes = rospy.get_param('~osm_use_solitary_nodes', False)
    repeat = rospy.get_param('~repeat', False)
    next_waypoint_proximity_switch = rospy.get_param('~next_waypoint_proximity_switch', False)
    min_time_near_goal = rospy.get_param('~min_time_near_goal', 1.)
    flip = rospy.get_param('~flip', False)
    max_height = rospy.get_param('~max_height', 1.)
    min_height = rospy.get_param('~min_height', 0.05)
    max_age = rospy.get_param('~max_age', 1.)
    trav_obstacle_field = rospy.get_param('~trav_obstacle_field', "obstacle")
    trav_topic = rospy.get_param('~trav_topic', "cloud_segmentation/lidar_cloud")
    odom_frame = rospy.get_param('~odom_frame', "gps_odom")
    max_relative_path_cost_change = rospy.get_param('~max_relative_path_cost_change', 1.1)
    heading_diff_cost = rospy.get_param('~heading_diff_cost', 5)
    

    node = PathPlanner(gpx_assignment,
                        publish_pcd,
                        goal_reached_distance,
                        trav_max_dist,
                        trav_radius,
                        untrav_cost,
                        absence_cost,
                        max_traversable_cost,
                        long_term_memory_longevity,
                        short_term_memory_longevity,
                        trav_inheritance_radius,
                        robot_base_frame,
                        max_goal_untrav_cost,
                        max_path_cost,
                        max_subgraph_time,
                        use_osm,
                        osm_use_solitary_nodes,
                        repeat,
                        next_waypoint_proximity_switch,
                        min_time_near_goal,
                        flip,
                        points_absence_radius,
                        max_height,
                        min_height,
                        max_age,
                        trav_obstacle_field,
                        trav_topic,
                        odom_frame,
                        max_relative_path_cost_change,
                        heading_diff_cost)

    node.run()


class TQDMBytesReader(object):

    def __init__(self, fd, **kwargs):
        self.fd = fd
        kw = {
            'smoothing': 0.0,
            'mininterval': 1.0,
        }
        kw.update(kwargs)
        self.tqdm = tqdm(**kw)

    def read(self, size=-1):
        bytes = self.fd.read(size)
        self.tqdm.update(len(bytes))
        return bytes

    def readline(self):
        bytes = self.fd.readline()
        self.tqdm.update(len(bytes))
        return bytes

    def readinto(self, b):
        num_bytes = self.fd.readinto(b)
        self.tqdm.update(len(num_bytes))
        return num_bytes

    def __enter__(self):
        self.tqdm.__enter__()
        return self

    def __exit__(self, *args, **kwargs):
        return self.tqdm.__exit__(*args, **kwargs)


if __name__ == '__main__':
    main()
