#!/usr/bin/env python

# SPDX-License-Identifier: BSD-3-Clause
# SPDX-FileCopyrightText: Czech Technical University in Prague

"""
This node imposes a minimum limit on the covariance of GPS measurements. This can be used to limit jitter of a fused
odometry caused by the very accurate, but still jumping measurements. It also filters some susceptible values of fix.

It can either subscribe to :class:`sensor_msgs.msg.NavSatFix` messages alone, or to these messages accompanied by
:class:`gps_to_path.msg.NavSatDetailedStatus` messages. It automatically tries to subscribe to both, and when it detects
that the detailed status messages are available, it only uses the algorithm that takes the detailed status into account.
"""
from collections import deque
from threading import Lock
import utm

from geometry_msgs.msg import PoseWithCovarianceStamped
from message_filters import TimeSynchronizer, Subscriber
import rospy
from sensor_msgs.msg import NavSatFix, NavSatStatus
from gps_to_path.msg import NavSatDetailedStatus, NavSatFixQuality
from tf2_ros import Buffer, TransformListener

rospy.init_node("nav_sat_fix_filter")

min_fix_cov = float(rospy.get_param("~min_fix_cov", 1e-5))
min_float_cov = float(rospy.get_param("~min_float_cov", 1e-3))
max_cov = float(rospy.get_param("~max_cov", 10))

min_fix_lat_cov = float(rospy.get_param("~min_fix_lat_cov", min_fix_cov))
min_fix_lon_cov = float(rospy.get_param("~min_fix_lon_cov", min_fix_cov))
min_fix_alt_cov = float(rospy.get_param("~min_fix_alt_cov", min_fix_cov))

min_float_lat_cov = float(rospy.get_param("~min_float_lat_cov", min_float_cov))
min_float_lon_cov = float(rospy.get_param("~min_float_lon_cov", min_float_cov))
min_float_alt_cov = float(rospy.get_param("~min_float_alt_cov", min_float_cov))

average_fix_cov_multiplier = float(rospy.get_param("~average_fix_cov_multiplier", 10))
degraded_fix_cov_multiplier = float(rospy.get_param("~degraded_fix_cov_multiplier", 100))

fix_lost_duration = rospy.Duration(rospy.get_param("~fix_lost_duration", 1.0))
fix_reconvergence_duration = rospy.Duration(rospy.get_param("~fix_reconvergence_duration", 20.0))
max_corrections_age = rospy.Duration(rospy.get_param("~max_corrections_age", 10.0))

state_names = {
    NavSatFixQuality.STATE_NO_FIX: "NO_FIX",
    NavSatFixQuality.STATE_HAS_FIX: "HAS_FIX",
    NavSatFixQuality.STATE_FIX_RECONVERGING: "FIX_RECONVERGING",
}

fix_quality_names = {
    NavSatFixQuality.QUALITY_OK: "OK",
    NavSatFixQuality.QUALITY_AVERAGE: "AVERAGE",
    NavSatFixQuality.QUALITY_DEGRADED: "DEGRADED",
    NavSatFixQuality.QUALITY_BAD: "BAD",
}

RTK_FIX_STATUSES = (NavSatStatus.STATUS_GBAS_FIX, NavSatStatus.STATUS_SBAS_FIX)

pub = rospy.Publisher("gps/fix_filtered", NavSatFix, queue_size=10)
pub_quality = rospy.Publisher("gps/fix_quality", NavSatFixQuality, queue_size=10)

processed_stamps = deque(maxlen=10)
processed_stamps_lock = Lock()


def fix_only_cb(fix_msg):
    """Callback for fix messages without status.

    :param NavSatFix fix_msg: 
    :return: 
    """
    # create a fake status message

    status_msg = NavSatDetailedStatus()
    status_msg.header = fix_msg.header

    satellites_used = {
        NavSatStatus.STATUS_NO_FIX: 0,
        NavSatStatus.STATUS_FIX: 7,
        NavSatStatus.STATUS_SBAS_FIX: 12,
        NavSatStatus.STATUS_GBAS_FIX: 15,
    }
    status_msg.satellites_used = satellites_used[fix_msg.status.status]

    if fix_msg.status.status in RTK_FIX_STATUSES:
        status_msg.last_corrections_time = rospy.Time.now()
        status_msg.integer_ambiguity_ratio = 3.0
    elif fix_msg.status.status == NavSatStatus.STATUS_FIX:
        if max(fix_msg.position_covariance[0], fix_msg.position_covariance[4]) < 0.1:
            status_msg.last_corrections_time = rospy.Time.now()
            status_msg.integer_ambiguity_ratio = 1.3
        else:
            status_msg.last_corrections_time = rospy.Time.now() - rospy.Duration(120)
            status_msg.integer_ambiguity_ratio = 0

    # run the filter with the fake status message
    filtered_fix, fix_quality = filter_fix(fix_msg, status_msg)

    with processed_stamps_lock:
        if fix_msg.header.stamp not in processed_stamps:
            if filtered_fix is not None:
                pub.publish(filtered_fix)
            pub_quality.publish(fix_quality)
            processed_stamps.append(fix_msg.header.stamp)


def fix_with_status_cb(fix_msg, status_msg):
    """Callback for fix messages with status.

    :param NavSatFix fix_msg: 
    :param NavSatDetailedStatus status_msg: 
    """
    # once we get a fix with status, we no longer need the fix_only version
    fix_only_sub.unregister()

    filtered_fix, fix_quality = filter_fix(fix_msg, status_msg)

    with processed_stamps_lock:
        if fix_msg.header.stamp not in processed_stamps:
            if filtered_fix is not None:
                pub.publish(filtered_fix)
            pub_quality.publish(fix_quality)
            processed_stamps.append(fix_msg.header.stamp)


def filter_fix(fix_msg, status_msg):
    """Callback for fix messages with status.

    :param NavSatFix fix_msg: 
    :param NavSatDetailedStatus status_msg: 
    """
    global last_cb_stamp
    global last_fix_msg
    global fix_regained_stamp
    global state

    fix_quality_msg = NavSatFixQuality()
    fix_quality_msg.header = fix_msg.header
    fix_quality_msg.quality = NavSatFixQuality.QUALITY_BAD
    fix_quality_msg.state = NavSatFixQuality.STATE_NO_FIX
    fix_quality_msg.covariance_multiplier = float('nan')

    if last_cb_stamp > rospy.Time.now() + rospy.Duration(3):
        rospy.loginfo("ROS time jumped backwards, resetting.")
        last_fix_msg = None
        state = NavSatFixQuality.STATE_NO_FIX
    last_cb_stamp = rospy.Time.now()

    if state == NavSatFixQuality.STATE_NO_FIX:
        state = NavSatFixQuality.STATE_HAS_FIX

    if state == NavSatFixQuality.STATE_HAS_FIX and last_fix_msg is not None \
            and fix_msg.header.stamp - last_fix_msg.header.stamp > fix_lost_duration:
        state = NavSatFixQuality.STATE_FIX_RECONVERGING
        fix_regained_stamp = fix_msg.header.stamp
        rospy.loginfo("Fix lost")
    last_fix_msg = fix_msg

    if state == NavSatFixQuality.STATE_FIX_RECONVERGING and \
            fix_msg.header.stamp > fix_regained_stamp + fix_reconvergence_duration:
        state = NavSatFixQuality.STATE_HAS_FIX
        fix_regained_stamp = None
        rospy.loginfo("Fix regained")

    rospy.loginfo_throttle_identical(20.0, "Fix state: " + state_names[state])

    if state != NavSatFixQuality.STATE_HAS_FIX:
        fix_quality_msg.state = state
        return None, fix_quality_msg

    cov = list(fix_msg.position_covariance)
    has_corrections = rospy.Time.now() - status_msg.last_corrections_time < max_corrections_age

    fix_quality = NavSatFixQuality.QUALITY_OK
    if not has_corrections:
        fix_quality = max(fix_quality, NavSatFixQuality.QUALITY_DEGRADED)
    if status_msg.satellites_used < 4:
        fix_quality = max(fix_quality, NavSatFixQuality.QUALITY_BAD)
    elif status_msg.satellites_used < 5:
        fix_quality = max(fix_quality, NavSatFixQuality.QUALITY_DEGRADED)
    elif status_msg.satellites_used < 15:
        fix_quality = max(fix_quality, NavSatFixQuality.QUALITY_AVERAGE)
    if status_msg.integer_ambiguity_ratio < 1:
        fix_quality = max(fix_quality, NavSatFixQuality.QUALITY_DEGRADED)
    elif status_msg.integer_ambiguity_ratio < 1.8:
        fix_quality = max(fix_quality, NavSatFixQuality.QUALITY_AVERAGE)
    if fix_msg.status.status == NavSatStatus.STATUS_NO_FIX:
        fix_quality = max(fix_quality, NavSatFixQuality.QUALITY_BAD)
    if max(cov[0], cov[4]) > max_cov:
        fix_quality = max(fix_quality, NavSatFixQuality.QUALITY_BAD)

    rospy.loginfo_throttle_identical(20.0, "Fix quality: " + fix_quality_names[fix_quality])

    if fix_quality == NavSatFixQuality.QUALITY_BAD:
        fix_quality_msg.state = state
        fix_quality_msg.quality = fix_quality
        return None, fix_quality_msg

    min_lat_cov = min_fix_lat_cov if fix_msg.status.status in RTK_FIX_STATUSES else min_float_lat_cov
    min_lon_cov = min_fix_lon_cov if fix_msg.status.status in RTK_FIX_STATUSES else min_float_lon_cov
    min_alt_cov = min_fix_alt_cov if fix_msg.status.status in RTK_FIX_STATUSES else min_float_alt_cov

    multipliers = {
        NavSatFixQuality.QUALITY_OK: 1,
        NavSatFixQuality.QUALITY_AVERAGE: average_fix_cov_multiplier,
        NavSatFixQuality.QUALITY_DEGRADED: degraded_fix_cov_multiplier,
    }
    multiplier = multipliers[fix_quality]

    cov[0] = multiplier * max(cov[0], min_lat_cov)
    cov[4] = multiplier * max(cov[4], min_lon_cov)
    cov[8] = multiplier * max(cov[8], min_alt_cov)
    fix_msg.position_covariance = tuple(cov)

    fix_quality_msg.quality = fix_quality
    fix_quality_msg.state = state
    fix_quality_msg.covariance_multiplier = multiplier

    return fix_msg, fix_quality_msg


def initial_pose_cb(pose_msg):
    """Callback for rviz marker that sets the robot pose.

    :param PoseWithCovarianceStamped pose_msg: 
    """
    global last_cb_stamp
    global fix_regained_stamp
    global state
    global last_fix_msg

    if last_fix_msg is None:
        rospy.logerr("UTM zone is not known. Need to receive at least one bad fix message to proceed.")
        return

    try:
        _, _, utm_zone, _ = utm.from_latlon(last_fix_msg.latitude, last_fix_msg.longitude)
        utm_pose = tf_buffer.transform(pose_msg, "utm", rospy.Duration(1))
        lat, lon = utm.to_latlon(utm_pose.pose.pose.position.x, utm_pose.pose.pose.position.y, utm_zone)
        fix_msg = NavSatFix()
        fix_msg.header.stamp = rospy.Time.now()
        fix_msg.header.frame_id = last_fix_msg.header.frame_id
        fix_msg.status.status = NavSatStatus.STATUS_GBAS_FIX
        fix_msg.status.service = NavSatStatus.SERVICE_GPS
        fix_msg.latitude = lat
        fix_msg.longitude = lon
        fix_msg.altitude = last_fix_msg.altitude
        fix_msg.position_covariance_type = NavSatFix.COVARIANCE_TYPE_DIAGONAL_KNOWN
        fix_msg.position_covariance = [1e-4, 0, 0, 0, 1e-4, 0, 0, 0, 1]

        fix_status_msg = NavSatDetailedStatus()
        fix_status_msg.header = fix_msg.header
        fix_status_msg.last_corrections_time = rospy.Time.now()
        fix_status_msg.integer_ambiguity_ratio = 10
        fix_status_msg.satellites_used = 100
        fix_status_msg.gps_time.header = fix_status_msg.header
        fix_status_msg.gps_time.time_ref = rospy.Time.now()
        fix_status_msg.gps_time.source = "user"

        state = NavSatFixQuality.STATE_HAS_FIX
        last_fix_msg = fix_msg

        fix_with_status_cb(fix_msg, fix_status_msg)
    except Exception as e:
        rospy.logerr(str(e))


tf_buffer = Buffer()
tf_listener = TransformListener(tf_buffer)

last_cb_stamp = rospy.Time.now()
last_fix_msg = None
fix_regained_stamp = None
state = NavSatFixQuality.STATE_NO_FIX

fix_only_sub = rospy.Subscriber("gps/fix", NavSatFix, fix_only_cb, queue_size=10)
fix_sub = Subscriber("gps/fix", NavSatFix, queue_size=10)
fix_status_sub = Subscriber("gps/fix_status", NavSatDetailedStatus, queue_size=10)
sub = TimeSynchronizer((fix_sub, fix_status_sub), queue_size=10)
sub.registerCallback(fix_with_status_cb)
initial_pose_sub = rospy.Subscriber("initialpose", PoseWithCovarianceStamped, initial_pose_cb, queue_size=1)

rospy.spin()
