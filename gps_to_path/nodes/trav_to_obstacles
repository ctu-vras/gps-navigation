#!/usr/bin/env python
from __future__ import division
import queue
import rospy
import overpy
import shapely.geometry as geometry
from shapely.prepared import prep
from shapely.ops import linemerge
import os
import utm
import numpy as np
from random import random
import gpx_to_waypoints
import time
import gpxpy
import gpxpy.gpx
from numpy.lib import recfunctions as rfn
import math
from sklearn.cluster import DBSCAN
from collections import Counter

import ros_numpy
import tf2_ros
from nav_msgs.msg import Path
from sensor_msgs.msg import NavSatFix, PointCloud2, PointField
from stamped_msgs.msg import Float64, Float64MultiArray
from std_msgs.msg import String
from geometry_msgs.msg import Point, Quaternion, PoseStamped, Pose, TransformStamped
from gpx_to_waypoints import gpx_to_waypoints
import std_msgs.msg
from math import sqrt, sin, cos, pi
from tf.transformations import quaternion_from_euler, quaternion_from_matrix, quaternion_multiply, euler_from_quaternion, quaternion_inverse, inverse_matrix, quaternion_matrix
from numpy import deg2rad, rad2deg, genfromtxt
import os.path
import osm_types
from copy import copy

MAX_AGE = 0.2

class TravToObstacles:
    def __init__(self):

        self.sub_pcd = rospy.Subscriber("cloud_segmentation/lidar_cloud", PointCloud2, self.handle_pcd, queue_size=1)

        self.sub_fix =  rospy.Subscriber("fix", NavSatFix, self.update_fix, queue_size = 10)
        self.gps_utm = None

        self.sub_azimuth = rospy.Subscriber("mag_azimuth", Float64, self.update_azimuth, queue_size=10)
        self.azimuth = None

        self.pub_obstacles = rospy.Publisher('trav_obstacles_pcd', PointCloud2, queue_size=10)
        self.obstacles_pcd_msg = PointCloud2()

        self.pub_obstacles_map = rospy.Publisher('trav_obstacles_pcd_map', PointCloud2, queue_size=10)
        self.obstacles_map_pcd_msg = PointCloud2()

        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)
        self.trans = None

        self.time_diff = None

    def update_fix(self, msg):
        self.gps_utm = np.array(utm.from_latlon(msg.latitude, msg.longitude)[:2]).reshape(1,2)

    def update_azimuth(self, msg):
        self.azimuth = msg.data

    def rotate(self,points,trans):
        R = quaternion_matrix([trans.transform.rotation.x,
                                    trans.transform.rotation.y,
                                    trans.transform.rotation.z,
                                    trans.transform.rotation.w])   
        R = R[:3,:3]
        points = np.matmul(R,points.T)
        points = points.T
        return points

    def transform_points(self,points,trans):
        points = self.rotate(points,trans)
        points[:,0] += trans.transform.translation.x
        points[:,1] += trans.transform.translation.y
        points[:,2] += trans.transform.translation.z
        return points

    def base_link_to_utm(self, points):
        # Rotation.
        angle = np.deg2rad(self.azimuth) + math.pi/2
        R = np.array([[np.cos(angle),-np.sin(angle)],
                        [np.sin(angle),np.cos(angle)]])
        points = np.matmul(R,points.T).T

        # Translation.
        points = points + self.gps_utm

        return points

    
    def process_points(self,points):
        points = points[points[:,0]!=-1.]         # Get rid of (-1,-1,-1) points.
        points = self.transform_points(points,self.trans)   # Transform to robot frame.
        points = points[(points[:,2] < 1) &
                        (points[:,2] > 0.05) &
                        ~((np.fabs(points[:,0]) < 0.5) &
                        (np.fabs(points[:,1]) < 0.5))]          # Get rid of points above robot.
        #points = points[]        # Get rid of low points.
        points = points[:,:2]                               # Get rid of z coord.
        utm_points = self.base_link_to_utm(points)
        return utm_points,points
        

    def handle_pcd(self,msg):
        
        # BAG ONLY ~~~~~~~~~
        if self.time_diff is None:
            self.time_diff = rospy.Time.now() - msg.header.stamp

        t = rospy.Time.now()
         
        if self.gps_utm is not None and self.azimuth is not None:
            if self.trans is not None and abs((msg.header.stamp + self.time_diff - t).to_sec()) < MAX_AGE:
                pcd_arr = ros_numpy.numpify(msg)
                pcd_arr = rfn.structured_to_unstructured(pcd_arr)

                pcd_arr = pcd_arr[np.where(pcd_arr[:,6] == 1)]
                pcd_arr = pcd_arr[:,:3]

                utm_untrav_points,untrav_points = self.process_points(pcd_arr)
                #t = time.time()
                #cluster_labels = DBSCAN(eps=0.3, min_samples=10).fit_predict(untrav_points)
                #print(time.time()-t)
                #untrav_points = untrav_points[np.where(cluster_labels!=-1)]
                #counter = Counter(cluster_labels)
                #print(counter)

                self.set_pcd_msg(utm_untrav_points)
                self.pub_obstacles.publish(self.obstacles_pcd_msg)

                self.set_map_pcd_msg(untrav_points)
                self.pub_obstacles_map.publish(self.obstacles_map_pcd_msg)
            else:
                print("throwing away old msg")

    def set_map_pcd_msg(self, points):
        pcd_data = np.zeros(len(points), dtype=[
                ('x', np.float32),
                ('y', np.float32),
                ('z', np.float32),
                ('r', np.float32),
                ('g', np.float32),
                ('b', np.float32)])


        pcd_data['x'] = points[:, 0]
        pcd_data['y'] = points[:, 1]
        pcd_data['z'] = np.zeros((points[:, 1].shape))
        pcd_data['r'] = 0.4
        pcd_data['g'] = 0.8
        pcd_data['b'] = 0.1

        self.obstacles_map_pcd_msg = ros_numpy.msgify(PointCloud2, pcd_data)

        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = "base_link"

        self.obstacles_map_pcd_msg.header = header

    def set_pcd_msg(self, points):
        pcd_data = np.zeros(len(points), dtype=[
                ('x', np.float32),
                ('y', np.float32)])


        pcd_data['x'] = points[:, 0]
        pcd_data['y'] = points[:, 1]
        #pcd_data['z'] = np.zeros((points[:, 1].shape))
        #pcd_data['r'] = 0.4
        #pcd_data['g'] = 0.8
        #pcd_data['b'] = 0.1

        self.obstacles_pcd_msg = ros_numpy.msgify(PointCloud2, pcd_data)

        header = std_msgs.msg.Header()
        header.stamp = rospy.Time.now()
        header.frame_id = "base_link"

        self.obstacles_pcd_msg.header = header

    def run(self):
        rate = rospy.Rate(10)
        while not self.trans:
            try:
                self.trans = self.tf_buffer.lookup_transform(
                    'base_link', 'os_sensor', rospy.Time())
            except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
                rate.sleep()
                continue
        rospy.spin()

        """ rate = rospy.Rate(10)

        while (not self.odom_gps_trans) or (not self.odom_base_link_trans):
            try:
                self.odom_gps_trans = self.tfBuffer.lookup_transform(
                    'odom', 'gps', rospy.Time())
                self.odom_base_link_trans = self.tfBuffer2.lookup_transform(
                    'odom', 'base_link', rospy.Time())
            except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
                rate.sleep()
                continue
        rospy.loginfo("Transformations obtained.") """

        #while not rospy.is_shutdown():
        #    self.main_cycle()
        #    rate.sleep()


def main():
    rospy.init_node('trav_to_obstacles')
    
    trav_to_obstacles = TravToObstacles()

    trav_to_obstacles.run()

if __name__ == '__main__':
    main()
