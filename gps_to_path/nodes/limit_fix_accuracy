#!/usr/bin/env python

# SPDX-License-Identifier: BSD-3-Clause
# SPDX-FileCopyrightText: Czech Technical University in Prague

"""
This node imposes a minimum limit on the covariance of GPS measurements. This can be used to limit jitter of a fused
odometry caused by the very accurate, but still jumping measurements. It also filters some susceptible values of fix.
"""

from message_filters import TimeSynchronizer, Subscriber
import rospy
from sensor_msgs.msg import NavSatFix, NavSatStatus
from gps_to_path.msg import NavSatDetailedStatus

rospy.init_node("limit_fix_accuracy")

min_cov = rospy.get_param("~min_cov", 1e-3)
max_cov = rospy.get_param("~max_cov", 10)

min_lat_cov = rospy.get_param("~min_lat_cov", min_cov)
min_lon_cov = rospy.get_param("~min_lon_cov", min_cov)
min_alt_cov = rospy.get_param("~min_alt_cov", min_cov)

degraded_fix_cov_multiplier = rospy.get_param("~degraded_fix_cov_multiplier", 100)

fix_lost_duration = rospy.Duration(rospy.get_param("~fix_lost_duration", 1.0))
fix_regain_cooldown = rospy.Duration(rospy.get_param("~fix_regain_cooldown", 10.0))
max_correction_age = rospy.Duration(rospy.get_param("~max_correction_age", 10.0))

STATE_NO_FIX = 0
STATE_HAS_FIX = 1
STATE_FIX_REGAINING = 2

state_names = {
    STATE_NO_FIX: "NO_FIX",
    STATE_HAS_FIX: "HAS_FIX",
    STATE_FIX_REGAINING: "FIX_REGAINING",
}

FIX_QUALITY_OK = 0
FIX_QUALITY_DEGRADED = 1
FIX_QUALITY_BAD = 2

fix_quality_names = {
    FIX_QUALITY_OK: "OK",
    FIX_QUALITY_DEGRADED: "DEGRADED",
    FIX_QUALITY_BAD: "BAD",
}

pub = rospy.Publisher("gps/fix_limited_accuracy", NavSatFix, queue_size=10)


def cb(fix_msg, status_msg):
    """Callback for fix messages.

    :param NavSatFix fix_msg: 
    :param NavSatDetailedStatus status_msg: 
    """
    global last_cb_stamp
    global last_fix_stamp
    global fix_regained_stamp
    global state

    if last_cb_stamp > rospy.Time.now() + rospy.Duration(3):
        rospy.loginfo("ROS time jumped backwards, resetting.")
        last_fix_stamp = None
        state = STATE_NO_FIX
    last_cb_stamp = rospy.Time.now()

    if state == STATE_NO_FIX:
        state = STATE_HAS_FIX

    if state == STATE_HAS_FIX and last_fix_stamp is not None and fix_msg.header.stamp - last_fix_stamp > fix_lost_duration:
        state = STATE_FIX_REGAINING
        fix_regained_stamp = fix_msg.header.stamp
    last_fix_stamp = fix_msg.header.stamp

    if state == STATE_FIX_REGAINING and fix_msg.header.stamp - fix_regained_stamp > fix_regain_cooldown:
        state = STATE_HAS_FIX
        fix_regained_stamp = None

    rospy.loginfo_throttle_identical(20.0, "Fix state: " + state_names[state])

    if state != STATE_HAS_FIX:
        return

    cov = list(fix_msg.position_covariance)

    fix_quality = FIX_QUALITY_OK
    if rospy.Time.now() - status_msg.last_corrections_time > max_correction_age:
        fix_quality = max(fix_quality, FIX_QUALITY_DEGRADED)
    if status_msg.satellites_used < 4:
        fix_quality = max(fix_quality, FIX_QUALITY_BAD)
    elif status_msg.satellites_used < 5:
        fix_quality = max(fix_quality, FIX_QUALITY_DEGRADED)
    if fix_msg.status.status == NavSatStatus.STATUS_NO_FIX:
        fix_quality = max(fix_quality, FIX_QUALITY_BAD)
    if max(cov[0], cov[4]) > max_cov:
        fix_quality = max(fix_quality, FIX_QUALITY_BAD)

    rospy.loginfo_throttle_identical(20.0, "Fix quality: " + fix_quality_names[fix_quality])

    if fix_quality == FIX_QUALITY_BAD:
        return

    multiplier = 1 if fix_quality == FIX_QUALITY_OK else degraded_fix_cov_multiplier
    cov[0] = multiplier * max(cov[0], min_lat_cov)
    cov[4] = multiplier * max(cov[4], min_lon_cov)
    cov[8] = multiplier * max(cov[8], min_alt_cov)
    fix_msg.position_covariance = tuple(cov)

    pub.publish(fix_msg)


last_cb_stamp = rospy.Time.now()
last_fix_stamp = None
fix_regained_stamp = None
state = STATE_NO_FIX

fix_sub = Subscriber("gps/fix", NavSatFix, queue_size=10)
fix_status_sub = Subscriber("gps/fix_status", NavSatDetailedStatus, queue_size=10)
sub = TimeSynchronizer((fix_sub, fix_status_sub), queue_size=10)
sub.registerCallback(cb)

rospy.spin()
